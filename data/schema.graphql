"""
Exposes a URL that specifies the behaviour of this scalar.
"""
directive @specifiedBy(
  """
  The URL that specifies the behaviour of this scalar.
  """
  url: String!
) on SCALAR

type Booking {
  id: ID!
  ts: DateTime!
  service_id: ID!
  service: Service
  requestor_id: ID!
  publisher_id: ID!
  start_date: DateTime!
  end_date: DateTime!
  booking_status: String!
  requestor: User
  publisher: User!
}

type BookingEdgesType {
  node: Booking!
  cursor: String!
}

"""
Type of reservation. Either REQUIRES_CONFIRMATION or AUTOMATIC
"""
enum BookingType {
  AUTOMATIC
  REQUIRES_CONFIRMATION
}

input CreateBookingArgs {
  service_id: ID!
  start_date: DateTime!
  end_date: DateTime!
}

input CreateServiceArgs {
  name: String!
  description: String!
  granularity: Int!
  min_time: Int!
  max_time: Int
  booking_type: BookingType!
  allowed_roles: [UniversityRole!]!
}

input Credentials {
  dni: String!
  password: String!
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

type Mutation {
  addUser(credentials: Credentials!): User!
  updateUser(update_args: UpdateUserArgs!, id: String!): User!
  createSession(credentials: Credentials!): Session!
  createService(creationArgs: CreateServiceArgs!): Service!
  updateService(update_args: UpdateServiceArgs!, service_id: String!): Service!
  createBooking(creationArgs: CreateBookingArgs!): Booking!
  cancelBooking(booking_id: String!): Booking!
  acceptBooking(accept: Boolean!, booking_id: String!): Booking!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type PaginatedBookingResponse {
  edges: [BookingEdgesType!]!
  pageInfo: PageInfo!
}

type PaginatedServiceResponse {
  edges: [ServicesEdgesType!]!
  pageInfo: PageInfo!
}

type PaginatedUserResponse {
  edges: [UsersEdgesType!]!
  pageInfo: PageInfo!
}

type Query {
  user(dni: String, id: String): User!
  users(first: Float, after: String): PaginatedUserResponse!
  services(
    first: Float
    query_term: String
    after: String
  ): PaginatedServiceResponse!
  myServices(
    first: Float
    query_term: String
    after: String
  ): PaginatedServiceResponse!
  myBookings(first: Float, after: String): PaginatedBookingResponse!
  myBookingsForPublisher(first: Float, after: String): PaginatedBookingResponse!
}

type Service {
  ts: DateTime!
  id: ID!
  publisher_id: ID!
  name: String!
  description: String!

  """
  Time slot granularity in seconds
  """
  granularity: Int!

  """
  Minimum amount of time slots to reserve
  """
  min_time: Int!

  """
  Maximum amount of time slots to reserve
  """
  max_time: Int
  booking_type: BookingType!
  allowed_roles: [UniversityRole!]!
  publisher: User
}

type ServicesEdgesType {
  node: Service!
  cursor: String!
}

type Session {
  token: String!
}

"""
Unversity role. STUDENT, PROFESSOR or NODO
"""
enum UniversityRole {
  STUDENT
  PROFESSOR
  NODO
}

input UpdateServiceArgs {
  name: String
  description: String
  granularity: Int
  min_time: Int
  max_time: Int
  booking_type: BookingType
  allowed_roles: [UniversityRole!]
}

input UpdateUserArgs {
  is_admin: Boolean
  can_publish_services: Boolean
}

type User {
  id: ID!
  ts: DateTime!
  dni: String!
  roles: [String!]!
  can_publish_services: Boolean!
}

type UsersEdgesType {
  node: User!
  cursor: String!
}
